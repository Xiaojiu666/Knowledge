### static关键字
静态局部变量的特性：
存储位置：处于静态储存区，当用static修饰局部变量的时候，它就改变了局部变量的存储位置，从原来的栈中存放改为静态存储区。
作用域：为局部静态作用域，即当定义它的函数结束的时候，作用域随之结束（不能被访问）。但是并没有被销毁，而是仍然存放在内存中，静态区的数据生命周期和程序的生命周期是一样的，直到程序结束，它的生命周期才结束。

###### 修饰局部变量
```c++
void test()
{
    int i = 0;
    i++;
    printf("%d ", i);   //打印结果：1 1 1 1 1 1 1 1 1 1

}
int main()
{
    int i = 0;
    for (i = 0; i < 10; i++)
    {
        test();
    }
    return 0;
}
```
这是因为 i 是局部变量，在函数调用完之后，i的生命周期也随之结束，当再次调用时，则重新新创建i。
```C++
void test()
{
    static int i = 0; //  打印结果：1 2 3 4 5 6 7 8 9 10
    i++;
    printf("%d ", i);
}
```

###### 修饰全局变量/方法
对于⼀个全局变量/方法，它既可以在本文件中被访问到，也可以在同⼀个工程中其它源文件被访问(添加 extern进行声明即可)。用 static 对全局变量进行修饰改变了其作用域范围，由原来的整个工程可见变成了本文件可见。多个文件操作的视同一个方法。

###### static修饰类成员变量
如果对类中的某个变量进行 static 修饰，则表示该变量以及所有的对象所有，存储空间中只存在一个副本，可以通过类和对象去调用。
静态非常量数据成员，其只能在类外定义和初始化，在类内仅是声明而已。
static 类对象必须要在类外进行初始化，static 修饰的变量先于对象存在，所以 static 修 饰的变量要在类外初始化；
在模块内的 static 全局变量可以被模块内所有函数访问，但不能被模块外其它函数访问；

###### static修饰类成员函数
如果 C++ 中对类中的某个函数用 static 修饰，则表示该函数属于一个类而 不是属于此类的任何特定对象；  
- 在模块内的 static 函数只可被这⼀模块内的其它函数调用，这个函数的使用范围被限制在声明它的模块内；
- 在类中的 static 成员函数属于整个类所拥有，这个函数不接收 this 指针，因而只能访问类的 static 成员变量。
- 由于 static 修饰的类成员属于类，不属于对象，因此 static 类成员函数是没有 this 指针， this 指针是指向本对象的指针，正因为没有 this 指针，所以 static 类成员函数不能访问⾮ static 的类成员，只能访问 static修饰的类成员；
- static 成员函数不能被 virtual 修饰，static 成员不属于任何对象或实例，所以加上 virtual 没有任何实际意义；因为虚函数的实现是为每⼀个对象分配⼀个vptr 指针，而vptr 是通过 this 指针调用的，所以不能为 virtual；虚函数的调用关系，this->vptr->ctable->virtual function


### extern
extern 存储类用于提供一个全局变量的引用，全局变量对所有的程序文件都是可见的。当您使用 'extern' 时，对于无法初始化的变量，会把变量名指向一个之前定义过的存储位置。

当您有多个文件且定义了一个可以在其他文件中使用的全局变量或函数时，可以在其他文件中使用 extern 来得到已定义的变量或函数的引用。可以这么理解，extern 是用来在另一个文件中声明一个全局变量或函数。

extern 修饰符通常用于当有两个或多个文件共享相同的全局变量或函数的时候，如下所示：

第一个文件：main.cpp
```C++
#include <iostream>

int count ;
extern void write_extern();

int main()
{
   count = 5;
   write_extern();
}
```
第二个文件：support.cpp
```C++
#include <iostream>

extern int count;

void write_extern(void)
{
   std::cout << "Count is " << count << std::endl;
}
```
