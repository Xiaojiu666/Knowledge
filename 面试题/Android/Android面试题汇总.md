



##	Android知识汇总



##	基础篇

####	四大组件

###### Activity:

启动模式:

- 默认

- singleTop

- singleTask

- singleInstance

  A(默认)--B(singleInstance)--C(默认)  按下Back键 C 返回A 返回B

生命周期:

![img](https://img-blog.csdn.net/20160717151833576?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

###### Server:

启动方式：

```
StartServer 和 BinderServer
```

服务类型:

```
分为本地服务（LocalService）和远程服务（RemoteService）

1、本地服务依附在主进程上而不是独立的进程，这样在一定程度上节约了资源，另外Local服务因为是在同一进程因此不需要IPC，

也不需要AIDL。相应bindService会方便很多。主进程被Kill后，服务便会终止。

2、远程服务为独立的进程，对应进程名格式为所在包名加上你指定的android:process字符串。由于是独立的进程，因此在Activity所在进程被Kill的时候，该服务依然在
```



###### BroadcastReceiver:

广播类型:



###### ContentProvider:

作用

####	Handler机制

组成部分：

- Looper ：负责关联线程以及消息的分发，在该线程下从 MessageQueue 获取 Message，分发给 Handler。
- MessageQueue ：消息队列，负责Hander发送过来的Msg存储与管理，
- Handler : 负责发送并处理消息，面向开发者，提供 API，并隐藏背后实现的细节。
- Message：final类不可继承， 实现了Parcelable 序列化接口，可以在不同进程之间传递。

问题：

1.为什么Looper死循环没能造成UI线程卡死

```
之所以死循环，可以保证UI线程不会被退出，因为Android中界面绘制都是通过Handler消息来实现，这样可以让界面保持可绘制的状态。

1，epoll模型
当没有消息的时候会epoll.wait，等待句柄写的时候再唤醒，这个时候其实是阻塞的。

2，所有的ui操作都通过handler来发消息操作。
比如屏幕刷新16ms一个消息，你的各种点击事件，所以就会有句柄写操作，唤醒上文的wait操作，所以不会被卡死了。
```



2.一个线程有几个looper？如何保障线程和Looper的管理？几个Handler？同一个Looper是怎么区分不同的Handler的?（保证消息Handler和Msg对应的）

一个线程只能有一个Looper，通过ThreadLocal 进行管理looper中多个线程 ，无数的Handler 但是都公用一个Loop，Handler#enqueueMessage方法中，会将当前Msg.targt = this;从而达到绑定区分

3.什么是HandlerTheard？

简单来说就是一个自带Looper的子线程，不需要自己管理Looper的生命周期

参考资料：

- https://blog.csdn.net/u013700040/article/details/105655154
- https://blog.csdn.net/ly502541243/article/details/52414637



####	自定义View



#### 性能优化

时间:

	-	减少不必要的对象、成员变量
	-	尽量使用线程池
	-	避免加载大图，
	-	适当使用软引用和弱引用

空间:

健壮性:

美观性:



##

##	进阶篇

###	JAVA篇

####	数据结构

######	线性表

- 顺序表(数组)

  ```
  数组由一组相同的数据类型组成。它存储在连续的内存空间内，使用索引可以找到元素的地址。
  数组包括一维数组和多维数组,一维数组是最简单的数据结构,也是最常用的。
  ```

- 链表

  ```
  链表看起来更像树，而不是数组，它使用一组结点来表示一个序列。每一个结点都包含数据和一个指针。
  在链表中，结点中的数据可以为任意类型，而指针则是指向下一结点的引用。
  链表不是一个循环数据结构，所以尾结点没有指向头结点的指针，指针为空。
  ```

- 双向链表

  ```
  一个双向链表首先是一个链表，但是在每个结点中有两个指针，前驱指针指向前驱结点，后继指针指向后继结点。
  双向链表也有一个头结点，头结点的后继指针指向第一个结点。
  最后一个结点的后继指针指向空，但是如果最后一个结点的后继指针指向第一个结点，这时称这个链表为双向循环链表。
  双向循环链表能非常方便地从每个结点查找它的前驱结点和后继结点。
  ```

- 栈

  ```
  栈是一个有着「后进先出」特性的基础数据结构，这就意味着最后一个入栈的元素，也是第一个出栈的。
  栈就像是一个桶，想要得到桶里的第一个进去的，必须把其他的书都先拿走。
  向栈中添加一个元素的操作被称为 Push（入栈），删除一个元素的操作被称为 Pop（出栈），
  查看且不删除最后一个入栈的元素的操作被称为 Top 。
  实现栈的常用方法是使用链表（LinkedList），也可以使用不允许空值的 StackArray（使用数组实现），还有允许空值的 Vector
  ```

- 队列

  ```
  队列是一种特殊的线性表，只允许在表的头部（front处）进行删除操作，在表的尾部（rear处）进行插入操作的线性数据结构，这种结构就叫做队列。
  进行插入操作的一端称为队尾，进行删除操作的一端称为队尾。
  ```

- 哈希表

######	树存储结构

######	图存储结构

问题:

1. 哈希冲突
   - 开放定址法：
   - 再哈希法：
   - 链地址法：

#### 集合

###### List(列表)

###### Set(集合)

###### Map(映射)

#### Java内存模型

　在Java虚拟机规范中试图定义一种Java内存模型（Java Memory  Model，JMM）来屏蔽各个硬件平台和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果。那么Java内存模型规定了哪些东西呢，它定义了程序中变量的访问规则，往大一点说是定义了程序执行的次序。注意，为了获得较好的执行性能，Java内存模型并没有限制执行引擎使用处理器的寄存器或者高速缓存来提升指令执行速度，也没有限制编译器对指令进行重排序。也就是说，在java内存模型中，也会存在缓存一致性问题和指令重排序的问题。

　　Java内存模型规定所有的变量都是存在主存当中（类似于前面说的物理内存），每个线程都有自己的工作内存（类似于前面的高速缓存）。线程对变量的所有操作都必须在工作内存中进行，而不能直接对主存进行操作。并且每个线程不能访问其他线程的工作内存。

​

####	多线程

###### 并发编程中的三个概念

- 原子性问题

  即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。

  一个很经典的例子就是银行账户转账问题：

  　　比如从账户A向账户B转1000元，那么必然包括2个操作：从账户A减去1000元，往账户B加上1000元。

  　　试想一下，如果这2个操作不具备原子性，会造成什么样的后果。假如从账户A减去1000元之后，操作突然中止。然后又从B取出了500元，取出500元之后，再执行 往账户B加上1000元 的操作。这样就会导致账户A虽然减去了1000元，但是账户B没有收到这个转过来的1000元。

- 可见性问题

  可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。



- 有序性问题

  有序性：即程序执行的顺序按照代码的先后顺序执行。

  举个简单的例子，看下面这段代码：

  ```
  int` `i = ``0``;        
  boolean` `flag = ``false``;
  i = ``1``;        ``//语句1  
  flag = ``true``;     ``//语句2、
  ```

  上面代码定义了一个int型变量，定义了一个boolean类型变量，然后分别对两个变量进行赋值操作。从代码顺序上看，语句1是在语句2前面的，那么JVM在真正执行这段代码的时候会保证语句1一定会在语句2前面执行吗？不一定，为什么呢？这里可能会发生指令重排序（Instruction Reorder）。

  　　下面解释一下什么是指令重排序，一般来说，处理器为了提高程序运行效率，可能会对输入代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的。

  　　比如上面的代码中，语句1和语句2谁先执行对最终的程序结果并没有影响，那么就有可能在执行过程中，语句2先执行而语句1后执行。

  　　但是要注意，虽然处理器会对指令进行重排序，但是它会保证程序最终结果会和代码顺序执行结果相同，那么它靠什么保证的呢？再看下面一个例子：

  ```
  int` `a = ``10``;  ``//语句1
  int` `r = ``2``;  ``//语句2
  a = a + ``3``;  ``//语句3
  r = a*a;   ``//语句4
  ```

  这段代码有4个语句，那么可能的一个执行顺序是：

  ![img](https://images0.cnblogs.com/blog/288799/201408/212305263939989.jpg)

  那么可不可能是这个执行顺序呢： 语句2  语句1  语句4  语句3

  不可能，因为处理器在进行重排序时是会考虑指令之间的数据依赖性，如果一个指令Instruction 2必须用到Instruction 1的结果，那么处理器会保证Instruction 1会在Instruction 2之前执行。

  　虽然重排序不会影响单个线程内程序执行的结果，但是多线程呢？下面看一个例子：

  ```
  //线程1:
  context = loadContext();  ``//语句1
  inited = ``true``;       ``//语句2
  ```

  ```
  //线程2:
  while``(!inited ){
   ``sleep()
  }
  doSomethingwithconfig(context);
  ```

  上面代码中，由于语句1和语句2没有数据依赖性，因此可能会被重排序。假如发生了重排序，在线程1执行过程中先执行语句2，而此是线程2会以为初始化工作已经完成，那么就会跳出while循环，去执行doSomethingwithconfig(context)方法，而此时context并没有被初始化，就会导致程序出错。

  从上面可以看出，指令重排序不会影响单个线程的执行，但是会影响到线程并发执行的正确性。

  也就是说，要想并发程序正确地执行，必须要保证原子性、可见性以及有序性。只要有一个没有被保证，就有可能会导致程序运行不正确。

###### 同步的几种方式：

######	volatile

###### synchronized

###### Lock

###### 参考资料:

-  [Java并发编程：volatile关键字解析](https://www.cnblogs.com/dolphin0520/p/3920373.html)



##	其他篇

https://blog.csdn.net/mythmayor/article/details/79959898
