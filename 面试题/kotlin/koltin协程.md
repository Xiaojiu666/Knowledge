#### 什么是协程

Kotlin 协程是一种用于异步编程的轻量级并发编程工具。它们允许您以顺序的方式编写异步代码，而不必依赖于传统的回调函数或显式的线程管理。Kotlin 协程建立在语言的 suspend 关键字之上，该关键字用于标记可以被暂停和恢复执行的函数。通过协程，您可以在代码中使用类似于同步代码的结构来处理异步操作，这使得代码更易于理解和维护。

Kotlin 协程提供了一种在不同线程之间轻松切换执行上下文的方式，从而使并发编程更加简单和灵活。您可以使用协程在非阻塞的方式下执行 IO 操作、计算密集型任务以及各种异步操作，而无需显式地管理线程。

#### 协程和线程的区别

- 并发模型：线程是操作系统级别的并发原语，它们由操作系统调度和管理。而协程则是在用户级别实现的并发机制，它们依赖于线程来运行，但可以更有效地利用线程，减少线程切换的开销。

- 资源消耗：线程是相对重量级的资源，每个线程都需要分配一定的内存和操作系统资源。而协程是轻量级的，可以在一个或少数几个线程上执行大量的协程，从而减少资源消耗。

- 并发控制：线程通常需要使用锁和同步原语来实现线程间的通信和共享状态。相比之下，协程可以通过挂起和恢复来暂停和继续执行，从而避免了显式的锁和同步。

- 代码结构：使用线程编写的代码通常需要使用回调函数或者显式地管理线程，这可能导致代码结构复杂和难以理解。而使用协程编写的代码更加直观和简洁，因为它们允许您以顺序的方式编写异步代码，而不必担心线程管理的细节。

#### 启动方式

launch、async 和 runBlocking 是 Kotlin 协程中常用的三种构建器，它们各自的作用和特点如下：

- launch：
  launch 用于启动一个新的协程，并且不会阻塞当前线程。它会返回一个 Job 对象，该对象可以用于取消协程的执行或等待其完成。
  launch 通常用于启动一个不需要返回结果的协程，比如执行一个后台任务。

```JAVA
    val job = CoroutineScope(Dispatchers.Default).launch {
        // 协程的代码逻辑
    }
```

- async：
    async 用于启动一个返回结果的协程，返回一个 Deferred 对象，可以通过调用 await() 方法来获取协程执行的结果。
    async 在执行时会立即返回一个 Deferred 对象，同时协程的执行是延迟执行的，只有在调用 await() 方法时才会真正启动协程执行。
```JAVA
    val deferred = CoroutineScope(Dispatchers.Default).async {
        // 协程的代码逻辑
        return@async result
    }

    val result = deferred.await()
```

-  runBlocking：
runBlocking 用于启动一个新的协程，并且会阻塞当前线程直到协程执行完成。
runBlocking 通常用于在顶层函数、测试代码或者 main 函数中启动协程，因为这些地方不允许使用 suspend 关键字来声明挂起函数。
```JAVA
fun main() {
    runBlocking {
        // 协程的代码逻辑
    }
}
```

综上所述，这三种构建器在使用场景和作用上有所不同：launch 用于启动不需要返回结果的协程，async 用于启动需要返回结果的协程，并且返回一个 Deferred 对象来获取结果，而 runBlocking 则用于在顶层函数或者测试代码中启动协程，并且会阻塞当前线程直到协程执行完成。

#### 协程的异常处理

coroutineScope 和 supervisorScope 都是 Kotlin 中的协程作用域,主要区别在于它们处理子协程异常的方式不同:

- coroutineScope  
  它会将子协程中的所有未处理异常向上冒泡抛出。  
  如果任一子协程失败,则整个 coroutineScope 都会被取消。  
  使用场景:需要所有任务都执行成功的情况。  
- supervisorScope  
  它会自动捕获子协程的所有异常,不会冒泡抛出。  
  即使一个子协程失败,其他协程也可以继续执行。  
  使用场景:允许个别任务失败,希望其他任务继续的情况。  
- 区别  
    coroutineScope 使用更严格,子协程之间互相依赖。  
    supervisorScope 更宽松,子协程之间相对独立。  
    coroutineScope 适合需要整体成功的任务。  
    supervisorScope 适合容错的异步任务流水线。  
  相同点
  两者都是结构化并发的协程作用域。
  都会等待子协程全部完成才结束。
