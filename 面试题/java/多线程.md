### 线程同步
##### Synchronized 关键字原理
[Synchronized原理](https://blog.csdn.net/li1325169021/article/details/121779198)
自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销。

synchronized的语义底层是通过监视器锁（monitor）的对象来完成，每个对象有一个monitor。每个synchronized修饰过的代码当它的monitor 被占用时就会处于锁定状态并且尝试获取monitor的所有权，过程如下所示：
（A）、 如果monitor的进入数为0，则该线程进入monitor，然后将进入数设置为 1，该线程即为 monitor的所有者。
（B）、如果线程己经占有该monitor，只是重新进入，则进入monitor 的进入数加1。
（C）、如果其他线程己经占用了monitor，则该线程进入阻塞状态，直到 monitor的进入数为 0，再重新尝试获取 monitor 的所有权。

##### 线程间通信之Lock
[线程间通信之Lock](https://www.mianshigee.com/note/detail/235886eoy/)

#####	java线程同步的方法有哪几种，请做解释(百度面试题)
[java线程同步的几种方法](https://www.cnblogs.com/mikechenshare/p/16736772.html)
-  synchronized关键字
-  wait和notify
-  使用特殊域变量volatile实现线程同步
-  使用重入锁实现线程同步
-  使用局部变量来实现线程同步
- 使用阻塞队列实现线程同步


### 线程池
##### 线程池得几种创建方式
[线程池得七种创建方式](https://blog.csdn.net/qq_41821963/article/details/125341789)
1. Executors.newFixedThreadPool：创建⼀个固定⼤⼩的线程池，可控制并发的线程数，超出的线程会在队列中等待；  
2. Executors.newCachedThreadPool：创建⼀个可缓存的线程池，若线程数超过处理所需，缓存⼀段时间后会回收，若线程数不够，则新建线程；  
3. Executors.newSingleThreadExecutor：创建单个线程数的线程池，它可以保证先进先出的执⾏顺序；  
4. Executors.newScheduledThreadPool：创建⼀个可以执⾏延迟任务的线程池；  
5. Executors.newSingleThreadScheduledExecutor：创建⼀个单线程的可以执⾏延迟任务的线程池；  
6. Executors.newWorkStealingPool：创建⼀个抢占式执⾏的线程池（任务执⾏顺序不确定）【JDK1.8 添加】。  
7. ThreadPoolExecutor：最原始的创建线程池的⽅式，它包含了 7 个参数可供设置，后⾯会详细讲。    
两种执行方式
```Java
public static class FixedThreadPool {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        ExecutorService es = Executors.newFixedThreadPool(2);
        // 方式1
        Future<String> submit = es.submit(() -> Thread.currentThread().getName());
        System.out.println(submit.get());
        // 方式2
        es.execute(() -> System.out.println(Thread.currentThread().getName()));
    }
}
// execute和submit都属于线程池的方法，execute只能提交Runnable类型的任务
// submit既能提交Runnable类型任务也能提交Callable类型任务。
// execute()没有返回值
// submit有返回值，所以需要返回值的时候必须使用submit
```
