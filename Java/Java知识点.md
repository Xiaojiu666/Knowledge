# Java特性

# Java设计原则

### 关键字

- static

  　　static可以修饰：属性，方法，代码段，内部类（静态内部类或嵌套内部类）

  > ​		static修饰的属性的初始化在编译期（类加载的时候），初始化后能改变。
>
  > 　　static修饰的属性所有对象都只有一个值。
>
  > 　　static修饰的属性强调它们只有一个。
>
  > 　　static修饰的属性、方法、代码段跟该类的具体对象无关，不创建对象也能调用static修饰的属性、方法等
>
  > 　　static和“this、super”势不两立，static跟具体对象无关，而this、super正好跟具体对象有关。
>
  > 　　static不可以修饰局部变量。

- final

  > final可以修饰属性，方法，类，局部变量（方法中的变量）
>
  > 　　final修饰的属性的初始化可以在编译期，也可以在运行期，初始化后不能被改变。
>
  > 　　final修饰的属性跟具体对象有关，在运行期初始化的final属性，不同对象可以有不同的值。
>
  > 　　final修饰的属性表明是一个常数（创建后不能被修改）。
>
  > 　　final修饰的方法表示该方法在子类中不能被重写；
>
  > 　　final修饰的类表示该类不能被继承。

- static final

  > ​		成员变量：属于类的变量且只能赋值一次。
>
  > ​		方法：属于类的方法且不可以被重写。
>
  > ​		内部类：属于外部类，且不能被继承
>



  

### 基础数据类型

- **float** **单精度浮点数**

  > 单精度浮点数在机内存占4个字节
>
  > 单精度浮点数有效数字8位
>
  > 单精度浮点数的表示范围：-3.40E+38~3.40E+38
>
  > 一般来说，CPU处理单精度浮点数的速度比处理双精度浮点数快
>
  > float a=1.3 编译报错，1.3属于双精度，双精度给浮点属于向下转型会造成精度损失，因此需要强制类型转换float f = (float)3.4;或者写成 float f = 3.4f;

- **double** **双精度浮点数**（Java中小数默认为double）

  > 双精度浮点数在机内存占8个字节
>
  > 双精度浮点数有效数字16位
>
  > 双精度浮点数的表示范围：-1.79E+308~-1.79E+308
>
  > java中默认声明的小数是double类型的
>

  

###	数据结构

######	线性表

- 顺序表(数组)

  > 数组由一组相同的数据类型组成。它存储在连续的内存空间内，使用索引可以找到元素的地址。
  > 数组包括一维数组和多维数组,一维数组是最简单的数据结构,也是最常用的。
  
- 链表

  > 链表看起来更像树，而不是数组，它使用一组结点来表示一个序列。每一个结点都包含数据和一个指针。
  > 在链表中，结点中的数据可以为任意类型，而指针则是指向下一结点的引用。
  > 链表不是一个循环数据结构，所以尾结点没有指向头结点的指针，指针为空。
  
- 双向链表

  > 一个双向链表首先是一个链表，但是在每个结点中有两个指针，前驱指针指向前驱结点，后继指针指向后继结点。
  > 双向链表也有一个头结点，头结点的后继指针指向第一个结点。
  > 最后一个结点的后继指针指向空，但是如果最后一个结点的后继指针指向第一个结点，这时称这个链表为双向循环链表。
  > 双向循环链表能非常方便地从每个结点查找它的前驱结点和后继结点。
  
- 栈

  > 栈是一个有着「后进先出」特性的基础数据结构，这就意味着最后一个入栈的元素，也是第一个出栈的。
  > 栈就像是一个桶，想要得到桶里的第一个进去的，必须把其他的书都先拿走。
  > 向栈中添加一个元素的操作被称为 Push（入栈），删除一个元素的操作被称为 Pop（出栈），
  > 查看且不删除最后一个入栈的元素的操作被称为 Top 。
  > 实现栈的常用方法是使用链表（LinkedList），也可以使用不允许空值的 StackArray（使用数组实现），还有允许空值的 Vector
  
- 队列

  > 队列是一种特殊的线性表，只允许在表的头部（front处）进行删除操作，在表的尾部（rear处）进行插入操作的线性数据结构，这种结构就叫做队列。
  > 进行插入操作的一端称为队尾，进行删除操作的一端称为队尾。
  
- 哈希表

######	树存储结构

######	图存储结构

问题: 

1. 哈希冲突
   - 开放定址法：
   - 再哈希法：
   - 链地址法：

### 集合

###### List(列表)

###### Set(集合)

###### Map(映射)



### Java并发编程

　在Java虚拟机规范中试图定义一种Java内存模型（Java Memory  Model，JMM）来屏蔽各个硬件平台和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果。那么Java内存模型规定了哪些东西呢，它定义了程序中变量的访问规则，往大一点说是定义了程序执行的次序。注意，为了获得较好的执行性能，Java内存模型并没有限制执行引擎使用处理器的寄存器或者高速缓存来提升指令执行速度，也没有限制编译器对指令进行重排序。也就是说，在java内存模型中，也会存在缓存一致性问题和指令重排序的问题。

　　Java内存模型规定所有的变量都是存在主存当中（类似于前面说的物理内存），每个线程都有自己的工作内存（类似于前面的高速缓存）。线程对变量的所有操作都必须在工作内存中进行，而不能直接对主存进行操作。并且每个线程不能访问其他线程的工作内存。

### Java内存模型

在介绍Java内存模型之前，我们先了解一下物理计算机中的并发问题，理解这些问题可以搞清楚内存模型产生的背景。物理机遇到的并发问题与虚拟机中的情况有不少相似之处，物理机的解决方案对虚拟机的实现有相当的参考意义。





###	多线程

###### 并发编程中的三个概念

- 原子性问题

  即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。

  一个很经典的例子就是银行账户转账问题：

  　　比如从账户A向账户B转1000元，那么必然包括2个操作：从账户A减去1000元，往账户B加上1000元。

  　　试想一下，如果这2个操作不具备原子性，会造成什么样的后果。假如从账户A减去1000元之后，操作突然中止。然后又从B取出了500元，取出500元之后，再执行 往账户B加上1000元 的操作。这样就会导致账户A虽然减去了1000元，但是账户B没有收到这个转过来的1000元。

- 可见性问题

  可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。

  

- 有序性问题

  有序性：即程序执行的顺序按照代码的先后顺序执行。

  举个简单的例子，看下面这段代码：

  ```
  int` `i = ``0``;        
  boolean` `flag = ``false``;
  i = ``1``;        ``//语句1  
  flag = ``true``;     ``//语句2、
  ```

  上面代码定义了一个int型变量，定义了一个boolean类型变量，然后分别对两个变量进行赋值操作。从代码顺序上看，语句1是在语句2前面的，那么JVM在真正执行这段代码的时候会保证语句1一定会在语句2前面执行吗？不一定，为什么呢？这里可能会发生指令重排序（Instruction Reorder）。

  　　下面解释一下什么是指令重排序，一般来说，处理器为了提高程序运行效率，可能会对输入代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的。

  　　比如上面的代码中，语句1和语句2谁先执行对最终的程序结果并没有影响，那么就有可能在执行过程中，语句2先执行而语句1后执行。

  　　但是要注意，虽然处理器会对指令进行重排序，但是它会保证程序最终结果会和代码顺序执行结果相同，那么它靠什么保证的呢？再看下面一个例子：

  ```
  int` `a = ``10``;  ``//语句1
  int` `r = ``2``;  ``//语句2
  a = a + ``3``;  ``//语句3
  r = a*a;   ``//语句4
  ```

  这段代码有4个语句，那么可能的一个执行顺序是：

  ![img](https://images0.cnblogs.com/blog/288799/201408/212305263939989.jpg)

  那么可不可能是这个执行顺序呢： 语句2  语句1  语句4  语句3

  不可能，因为处理器在进行重排序时是会考虑指令之间的数据依赖性，如果一个指令Instruction 2必须用到Instruction 1的结果，那么处理器会保证Instruction 1会在Instruction 2之前执行。

  　虽然重排序不会影响单个线程内程序执行的结果，但是多线程呢？下面看一个例子：

  ```
  //线程1:
  context = loadContext();  ``//语句1
  inited = ``true``;       ``//语句2
  ```

  ```
  //线程2:
  while``(!inited ){
   ``sleep() 
  }
  doSomethingwithconfig(context);
  ```

  上面代码中，由于语句1和语句2没有数据依赖性，因此可能会被重排序。假如发生了重排序，在线程1执行过程中先执行语句2，而此是线程2会以为初始化工作已经完成，那么就会跳出while循环，去执行doSomethingwithconfig(context)方法，而此时context并没有被初始化，就会导致程序出错。

  从上面可以看出，指令重排序不会影响单个线程的执行，但是会影响到线程并发执行的正确性。

  也就是说，要想并发程序正确地执行，必须要保证原子性、可见性以及有序性。只要有一个没有被保证，就有可能会导致程序运行不正确。

###### 同步的几种方式：

######	volatile

###### synchronized

###### Lock





# JAVA-NIO





###### 参考资料:

- [ByteBuffer常用方法解释](https://blog.csdn.net/u012345283/article/details/38357851)
- [用法小结](https://blog.csdn.net/mrliuzhao/article/details/89453082)
- [ByteBuffer详解](https://zhuanlan.zhihu.com/p/56876443)





###### 参考资料:

-  [Java并发编程：volatile关键字解析](https://www.cnblogs.com/dolphin0520/p/3920373.html)
-  [理解Java内存模型](https://juejin.cn/post/6844903716844208136)


