
### 基础
#### == 和 === 区别
== 比较的是值 通过Intrinsics.areEqual(b, c)来比较两个对象的值
=== 比较的时地址值


#### 协变 逆变 不变
协变(out) 只能作为输出,即只能读取类型参数T,不能写入T。适用于只输出泛型类型的场景。

```JAVA
interface Source<out T> {
    fun get(): T 
}
```
逆变(in) 只能作为输入,即只能写入类型参数T,不能读取T。适用于只输入泛型类型的场景。

```JAVA
interface Comparable<in T> {
    fun compareTo(other: T): Int
}
```
不变(默认)既可以作为输入也可以作为输出。

协变和逆变性通过类型投影来实现,可以帮助我们创建更灵活安全的泛型API。
注:
-   类不能申明出协变或逆变  
-   函数参数不能是逆变的,返回值不能是协变的  
-   出协变(out)时要确保泛型类型参数T只出现在输出位置  
-   逆变(in)时要确保T只出现在输入位置  

#### 为什么协变只能读取泛型，不能修改泛型？
答：因为 例如<Object> = <String> 泛型接收端是Object，而泛型具体端是String，由于具体端有很多很多Object的子类，
而泛型会被泛型擦除，所以无法明确你到底要修改那个子类啊
为什么逆变只能修改泛型，不能读取泛型？
答：因为 例如<String> = <Object> 泛型接收端是String，而泛型具体端是Object，由于接收端是String，而读取时，
会读取到String的父类，但是接收端是String，你却读取到String的父类，这个本来就是不合理的

#### object作用
- 创建单例对象(饿汉式)
    使用 object 关键字可以创建一个单例对象，该对象只能有一个实例，并且在整个应用程序生命周期中都可以被访问。这种方式是实现单例模式的一种简单且安全的方式。
- 定义匿名对象
    ```
    fun printInfo() {
        val person = object {
            val name = "John"
            val age = 30
        }
        println("${person.name}, ${person.age} years old")
    }
    ```
- 实现对象表达式
Kotlin 中的对象表达式允许你在需要时创建一个特定类型的临时对象，并实现其方法或属性。使用 object 关键字可以方便地创建对象表达式。
    ```
        val runnable = object : Runnable {
            override fun run() {
                println("Running...")
            }
        }
    ```
-  定义伴生对象
    ```
    class MyClass {
    companion object {
        const val CONST = 1
    }  
    }
    ```


### 高阶函数

#### 常见高阶函数

#### 高阶函数和回调函数的区别
-   高阶函数：
高阶函数是指接受函数作为参数，或者返回函数作为结果的函数。
高阶函数可以让代码更加灵活，可以将函数作为参数传递给其他函数，从而实现不同的行为。
Kotlin 中的高阶函数可以使用 lambda 表达式来实现，这样可以简化代码并提高可读性。
-   回调函数：
回调函数是指将一个函数作为参数传递给另一个函数，并在特定的事件发生时由另一个函数调用。
回调函数通常用于异步编程中，比如处理异步操作的结果或者处理事件驱动的编程模型。

#### 内联函数
不带参数，或是带有普通参数的函数，不建议使用 inline  
带有 lambda 函数参数的函数，建议使用 inline  
它便是在编译过程中，因为 lambda 参数 多出来的类，无疑中会增加内存的分配。

#### noinline 
内联函数的「函数参数」 不允许作为参数传递给非内联的函数，
